setwd("~/My Dropbox/R/soc.ca")
source("soc.ca.r")
# Setting your working directory
data        <- read.csv(file="wiki_data.csv", sep=";", encoding="UTF-8")
attach(data)
active      <- data.frame(careerprofile_maclean_cat, careerfoundation_maclean_cat,
years_between_edu_dir_cat, time_in_corp_before_ceo_cat,
age_as_ceo_cat, career_changes_cat2, mba, abroad, hd, phd,
education, author, placeofbirth, familyclass_bourdieu,
partnersfamily_in_whoswho, family_in_whoswho)
sup       	<- data.frame(size_prestige, ownership_cat_2, sector, location)
id          <- navn
set.passive(c("MISSING", "Missing", "Irrelevant", "residence_value_cat2: Udlandet"))
result      <- soc.ca(active, sup, id)
sample.id   <- 1:nrow(active)
sample.id   <- sample(sample.id, size=1500, replace=TRUE)
active.sample <- active[sample.id, ]
sample.id   <- 1:nrow(active)
sample.id   <- sample(sample.id, size=300000, replace=TRUE)
active.sample <- active[sample.id, ]
system.time(soc.ca(active.sample))
active <- active.sample
sup=NULL
identifier=NULL
passive="Missing"
active  <- data.frame(lapply(active, factor))               # Turn active variables into factor ## Slet det her og sæt en advarsel ind i stedet
sup     <- data.frame(lapply(sup, factor))                  # Turn sup variables into factor    ## Slet det her og sæt en advarsel ind i stedet
Q       <- ncol(active)                                     # Number of active variables
a.r     <- nrow(active)                                     # Number of active rows or the number of individuals
sup.n   <- sum(unlist(lapply(as.data.frame(sup), nlevels))) # Number of supplementary modalities
if ((nrow(sup)==0)==TRUE){                                  # This process is slow at + 150.000 individuals
sup             <- matrix(0, nrow=nrow(active), ncol=2)
sup[,1:2]       <- cbind(rep(0, nrow(active)), rep(0, nrow(active)))
colnames(sup)   <- c("No supplementary points defined 1", "No supplementary points defined 2")
}
ind.act <- indicator(active)
ind.sup <- indicator(sup) # This scales badly, when the sup element is NULL
ind.sup <- sup
sub         <- grepl(paste(passive, collapse="|"), colnames(ind.act))
set         <- 1:ncol(ind.act)
subset      <- set[!sub]
Qm    <- Q
for (i in seq(Q)){
lev <- levels(active[,i])
pasQ <- grepl(paste(passive, collapse="|"), lev)
if (any(pasQ==TRUE)==TRUE){
Qm <- Qm - 1
}
}
result      <- subset.ca.indicator(ind.act, ind.sup, subset, Q=Q , Qm=Qm)
if (identical(identifier, NULL)==TRUE){
identifier <- 1:nrow(active)
}
result$names.mod      <- colnames(ind.act)[subset]
result$names.ind      <- as.character(identifier)
result$names.sup      <- colnames(ind.sup)
result$names.passive  <- colnames(ind.act)[sub]
varnames    <- colnames(active)
ml          <- vector()
for (i in 1:ncol(active)){
ml         <- c(ml, rep(varnames[i], nlevels(active[,i])))
}
ml          <- ml[!sub]
mm          <- as.matrix(cbind(ml, 1:length(ml)))
md          <- matrix(, nrow=ncol(active), ncol=3)
rownames(md) <- varnames
colnames(md) <- c("Start", "End", "Modalities")
md          <- as.data.frame(md)
for (i in 1:ncol(active)){
mr         <- as.numeric(mm[,2][mm[,1]==varnames[i]])
md[i,1]    <- min(mr)
md[i,2]    <- max(mr)
md[i,3]    <- length(mr)
}
md[,1]      <- as.numeric(md[,1])
md[,2]      <- as.numeric(md[,2])
result$modal    <- md
variable <- vector()
for (i in 1:nrow(md)){
variable <- c(variable, rep(rownames(md)[i], md[i,3]))
}
result$variable <- variable
class(result)   <- "soc.ca"
Z.act = ind.act
Z.sup = ind.sup
subset
Q=Q
Qm=Qm
I <- dim(Z.act)[1]  # Number of individuals
J <- dim(Z.act)[2]  # Number of modalities >> Subset
Q <- Q              # Number of variables
# Inertias
P <- Z.act / sum(Z.act)       #
cm <- colSums(P)              # Column (modality) mass
rm <- rowSums(P)              # Row (individual) mass
diag.cm <- diag(1/ sqrt(cm))  # This commmand scales badly because it creates a individual X individual matrix - If this number could be obtained differently - for instance - through the Burt matrix - there is a substantial speed gain.
eP    <- rm %*% t(cm)           # Expected distances
S     <- (P - eP) / sqrt(eP)    # Euclidian distances
# Subsetting
K   <- length(subset)
S   <- S[ ,subset]
cm  <- cm[subset]
diag.cm <- diag.cm[subset, subset]
# Decomposition and eigenvectors
dec   <- svd(S)                 # Singular decomposition
eigen <- dec$d^2                # Eigenvector
# Principal coordinates
pc.mod <- diag.cm %*% dec$v %*% diag(dec$d)   # Principal coordinates for modalities
# Fast principal coordinates for individuals
if (identical(var(rm), 0)){
sqrm       <- 1/ sqrt(rm)
pc.ind     <- (sqrm[1] * dec$u) %*% diag(dec$d)
}else{
# Original principal coordinates for individuals
diag.rm <- diag(1/ sqrt(rm))
pc.ind  <- diag.rm %*% dec$u %*% diag(dec$d)   # Principal coordinates for individuals # This is a slow process, but it scales ok # Anders Holm adjustment
}
# Fast inertias
if (identical(var(rm), 0)){
inr.ind <- rm[1] * pc.ind^2
inr.mod <- diag(cm) %*% pc.mod^2
}else{
# Original inertias
inr.ind <- diag(rm) %*% pc.ind^2 # Inertia for row (Individuals) (mass x principal coordinates) # This is a slow process and it scales badly - diag(rm) is a individual X individual matrix. It is also sparse - so it might be possible to do it quicker.
inr.mod <- diag(cm) %*% pc.mod^2 # Inertia for columns (Modalities)
}
ctr.ind <- t(t(inr.ind) / dec$d^2) # Contribution for the individuals (inertia / eigenvalue)
ctr.mod <- t(t(inr.mod) / dec$d^2) # Contribution for the modalities
# Squared cosines or correlations
cor.ind <- inr.ind/colSums(inr.ind)  # Squared cosines for individuals
cor.mod <- inr.mod/rowSums(inr.mod)  # Squared cosines for modalities
# Chi-distances
# Supplementary principal coordinates
Z.star  <- Z.sup
I.star  <- dim(Z.sup)[1]
cs.star <- apply(Z.sup, 2, sum)
base    <- Z.star / matrix(rep(cs.star, I.star), nrow = I.star, byrow = TRUE)
f.s1    <- dec$u * sqrt(eigen) / sqrt(rm)   # Hvad er det her?
a.s1    <- f.s1 / sqrt(eigen)               # Og har vi det et andet sted - til når der skal subsettes???
pc.sup  <- t(base) %*% a.s1
t(base)
n <- t(base)
str(n)
a.s1
str(a.s1)
source('~/Dropbox/R/soc.ca/functions_analysis.r')
sample.id   <- 1:nrow(active)
sample.id   <- sample(sample.id, size=300000, replace=TRUE)
active.sample <- active[sample.id, ]
system.time(soc.ca(active.sample))
